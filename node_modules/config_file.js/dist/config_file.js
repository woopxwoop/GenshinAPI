"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigFile = void 0;
const fs_1 = __importDefault(require("fs"));
const json_manager_1 = require("./json_manager");
class ConfigFile extends json_manager_1.JsonManager {
    constructor(filePath, jsonOptions, defaultConfig, readonly = false, fastMode = false, route = []) {
        // TODO: allow custom json parser
        super(jsonOptions, JSON.parse(JSON.stringify(defaultConfig)), readonly, fastMode, route);
        this.filePath = filePath;
        this.defaultConfig = defaultConfig;
    }
    get(...keys) {
        const newRoute = [...this.route, ...keys];
        let currentData = undefined;
        if (this.fastMode) {
            currentData = this._currentData;
            const keyCount = keys.length;
            for (let i = 0; i < keyCount; i++) {
                const key = keys[i];
                if (Array.isArray(currentData)) {
                    currentData = currentData[key];
                }
                else {
                    currentData = currentData[key];
                }
            }
        }
        return new ConfigPathResolver(this, newRoute, currentData);
    }
    map(callback) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new ConfigPathResolver(this, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        return pathResolvers.map(callback);
    }
    find(predicate) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new ConfigPathResolver(this, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        const found = pathResolvers.find(predicate);
        return found;
    }
    filter(predicate) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new ConfigPathResolver(this, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        const filtered = pathResolvers.filter(predicate);
        return filtered;
    }
    forEach(callback) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new ConfigPathResolver(this, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        const len = pathResolvers.length;
        for (let i = 0; i < len; i++) {
            callback(pathResolvers[i]);
        }
    }
    saveSync(compact = false) {
        if (this.filePath === null)
            return this;
        const text = compact ? JSON.stringify(this.data) : JSON.stringify(this.data, null, 4);
        fs_1.default.writeFileSync(this.filePath, text);
        return this;
    }
    loadSync() {
        if (this.filePath === null)
            return this;
        if (!fs_1.default.existsSync(this.filePath)) {
            this.saveSync();
        }
        const text = fs_1.default.readFileSync(this.filePath, "utf-8");
        try {
            this.data = JSON.parse(text);
        }
        catch (e) {
            console.error(e);
        }
        return this;
    }
    async save(compact = false) {
        if (this.filePath === null)
            return this;
        const filePath = this.filePath;
        // TODO: allow custom json parser
        const text = compact ? JSON.stringify(this.data) : JSON.stringify(this.data, null, 4);
        await new Promise((resolve, reject) => fs_1.default.writeFile(filePath, text, { encoding: "utf-8" }, (err) => {
            if (err)
                reject(err);
            resolve();
        }));
        return this;
    }
    async load() {
        if (this.filePath === null)
            return this;
        const filePath = this.filePath;
        if (!fs_1.default.existsSync(filePath)) {
            await this.save();
        }
        const text = await new Promise((resolve, reject) => fs_1.default.readFile(filePath, { encoding: "utf-8" }, (err, data) => {
            if (err)
                reject(err);
            resolve(data);
        }));
        try {
            // TODO: allow custom json parser
            this.data = JSON.parse(text);
        }
        catch (e) {
            console.error(e);
        }
        return this;
    }
    resetData() {
        this.data = JSON.parse(JSON.stringify(this.defaultConfig));
        return this;
    }
}
exports.ConfigFile = ConfigFile;
class ConfigPathResolver extends json_manager_1.PathResolver {
    constructor(configFile, route, currentData) {
        super(configFile, route, currentData);
        this.configFile = configFile;
        this.filePath = configFile.filePath;
        this.defaultConfig = configFile.defaultConfig;
    }
    get(...keys) {
        const newRoute = [...this.route, ...keys];
        let currentData = undefined;
        if (this.fastMode) {
            currentData = this._currentData;
            const keyCount = keys.length;
            for (let i = 0; i < keyCount; i++) {
                const key = keys[i];
                if (Array.isArray(currentData)) {
                    currentData = currentData[key];
                }
                else {
                    currentData = currentData[key];
                }
            }
        }
        return new ConfigPathResolver(this.configFile, newRoute, currentData);
    }
    map(callback) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new ConfigPathResolver(this.configFile, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        return pathResolvers.map(callback);
    }
    find(predicate) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new ConfigPathResolver(this.configFile, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        const found = pathResolvers.find(predicate);
        return found;
    }
    filter(predicate) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new ConfigPathResolver(this.configFile, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        const filtered = pathResolvers.filter(predicate);
        return filtered;
    }
    forEach(callback) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new ConfigPathResolver(this.configFile, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        const len = pathResolvers.length;
        for (let i = 0; i < len; i++) {
            callback(pathResolvers[i]);
        }
    }
    saveSync(compact = false) {
        return this.configFile.saveSync(compact);
    }
    loadSync() {
        return this.configFile.loadSync();
    }
    async save(compact = false) {
        return await this.configFile.save(compact);
    }
    async load() {
        return await this.configFile.load();
    }
    resetData() {
        return this.configFile.resetData();
    }
}
