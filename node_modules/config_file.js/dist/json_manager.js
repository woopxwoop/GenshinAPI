"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidTypeError = exports.EditReadonlyError = exports.PathResolver = exports.JsonManager = void 0;
const json_utils_1 = require("./json_utils");
// TODO: return immutable values with structuredClone() if it is readonly.
class JsonManager {
    get data() {
        return this._data;
    }
    set data(value) {
        if (this.readonly)
            throw new EditReadonlyError();
        this._data = value;
        if (this.fastMode)
            this._currentData = this.getValue(undefined, true);
    }
    constructor(jsonOptions, data, readonly = false, fastMode = false, route = []) {
        this.jsonOptions = jsonOptions;
        this._data = data;
        this.readonly = readonly;
        this.fastMode = fastMode;
        this.route = route;
        this._currentData = this.route.length === 0 ? this._data : undefined;
    }
    set(key, value) {
        if (this.readonly)
            throw new EditReadonlyError();
        this.get(key).setHere(value);
        return this;
    }
    add(value) {
        if (this.readonly)
            throw new EditReadonlyError();
        if (!Array.isArray(this.getValue()))
            this.setHere([]);
        this.getValue().push(value);
        return this;
    }
    getValue(key, disableFastMode = false) {
        if (key === undefined) {
            if (this.fastMode && !disableFastMode)
                return this._currentData;
            if (this.route.length === 0) {
                return this.data;
            }
            const parent = this.getObjectByRoute(this.route.slice(0, -1));
            if (parent === null || parent === undefined)
                return undefined;
            const lastRouteKey = this.route.slice(-1)[0];
            if (Array.isArray(parent)) {
                if (typeof lastRouteKey !== "number")
                    return undefined;
                return parent[lastRouteKey];
            }
            else {
                if (typeof lastRouteKey !== "string")
                    return undefined;
                return parent[lastRouteKey];
            }
        }
        else {
            const currentObject = this.fastMode && !disableFastMode ? this._currentData : this.getObjectByRoute(this.route);
            if (currentObject === null || currentObject === undefined)
                return undefined;
            if (Array.isArray(currentObject)) {
                if (typeof key !== "number")
                    return undefined;
                return currentObject[key];
            }
            else {
                if (typeof key !== "string")
                    return undefined;
                return currentObject[key];
            }
        }
    }
    getAs(key) {
        return this.getValue(key);
    }
    getAsNumber(key) {
        const value = this.getValue(key);
        if (typeof value !== "number")
            throw new InvalidTypeError(value);
        return value;
    }
    getAsString(key) {
        const value = this.getValue(key);
        if (typeof value !== "string")
            throw new InvalidTypeError(value);
        return value;
    }
    getAsBoolean(key) {
        const value = this.getValue(key);
        if (typeof value !== "boolean")
            throw new InvalidTypeError(value);
        return value;
    }
    getAsBigint(key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed in this JsonManager.");
        const value = this.getValue(key);
        if (typeof value !== "bigint")
            throw new InvalidTypeError(value);
        return value;
    }
    getAsJsonObject(key) {
        const value = this.getValue(key);
        if (!(0, json_utils_1.isFlexJsonObject)(this.jsonOptions, value))
            throw new InvalidTypeError(value);
        return value;
    }
    getAsJsonArray(key) {
        const value = this.getValue(key);
        if (!(0, json_utils_1.isFlexJsonArray)(this.jsonOptions, value))
            throw new InvalidTypeError(value);
        return value;
    }
    getAsNullableNumber(key) {
        const value = this.getValue(key);
        if (typeof value !== "number" && value !== null)
            throw new InvalidTypeError(value);
        return value;
    }
    getAsNullableString(key) {
        const value = this.getValue(key);
        if (typeof value !== "string" && value !== null)
            throw new InvalidTypeError(value);
        return value;
    }
    getAsNullableBoolean(key) {
        const value = this.getValue(key);
        if (typeof value !== "boolean" && value !== null)
            throw new InvalidTypeError(value);
        return value;
    }
    getAsNullableBigint(key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed in this JsonManager.");
        const value = this.getValue(key);
        if (typeof value !== "bigint" && value !== null)
            throw new InvalidTypeError(value);
        // TODO: remove casting
        return value;
    }
    getAsNullableJsonObject(key) {
        const value = this.getValue(key);
        if (!(0, json_utils_1.isFlexJsonObject)(this.jsonOptions, value) && value !== null)
            throw new InvalidTypeError(value);
        return value;
    }
    getAsNullableJsonArray(key) {
        const value = this.getValue(key);
        if (!(0, json_utils_1.isFlexJsonArray)(this.jsonOptions, value) && value !== null)
            throw new InvalidTypeError(value);
        return value;
    }
    get(...keys) {
        const newRoute = [...this.route, ...keys];
        let currentData = undefined;
        if (this.fastMode) {
            currentData = this._currentData;
            const keyCount = keys.length;
            for (let i = 0; i < keyCount; i++) {
                const key = keys[i];
                if (Array.isArray(currentData)) {
                    currentData = currentData[key];
                }
                else {
                    currentData = currentData[key];
                }
            }
        }
        return new PathResolver(this, newRoute, currentData);
    }
    map(callback) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new PathResolver(this, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        return pathResolvers.map(callback);
    }
    find(predicate) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new PathResolver(this, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        const found = pathResolvers.find(predicate);
        return found;
    }
    filter(predicate) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new PathResolver(this, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        const filtered = pathResolvers.filter(predicate);
        return filtered;
    }
    forEach(callback) {
        const dataHere = this.getAs();
        const isArray = Array.isArray(dataHere);
        const keys = isArray ? dataHere.map((_, i) => i) : Object.keys(dataHere);
        const pathResolvers = keys.map(key => new PathResolver(this, [...this.route, key], this.fastMode ? (isArray ? dataHere[key] : dataHere[key]) : undefined));
        const len = pathResolvers.length;
        for (let i = 0; i < len; i++) {
            callback(pathResolvers[i]);
        }
    }
    detach() {
        return new JsonManager(this.jsonOptions, (this.fastMode ? this._currentData : this.getValue()), this.readonly, this.fastMode);
    }
    asObject() {
        const dataHere = this.getAs();
        if (Array.isArray(dataHere))
            throw new InvalidTypeError(dataHere);
        return this;
    }
    asArray() {
        const dataHere = this.getAs();
        if (!Array.isArray(dataHere))
            throw new InvalidTypeError(dataHere);
        return this;
    }
    has(...keys) {
        let obj = this.getValue();
        for (let i = 0; i < keys.length; i++) {
            if (obj === null || typeof obj !== "object")
                return false;
            const key = keys[i];
            if (Array.isArray(obj)) {
                if (typeof key !== "number")
                    return false;
                obj = obj[key];
            }
            else {
                if (typeof key !== "string")
                    return false;
                obj = obj[key];
            }
            if (obj === undefined) {
                return false;
            }
        }
        return true;
    }
    exists() {
        return this.getValue() !== undefined;
    }
    resetPath() {
        this.route.splice(0, this.route.length);
        return this;
    }
    setHere(value) {
        if (this.readonly)
            throw new EditReadonlyError();
        if (this.route.length === 0) {
            this.data = value;
            return;
        }
        this.createPath(this.route);
        const parent = this.getObjectByRoute(this.route.slice(0, -1));
        const lastRouteKey = this.route.slice(-1)[0];
        if (Array.isArray(parent)) {
            parent[lastRouteKey] = value;
        }
        else {
            parent[lastRouteKey] = value;
        }
    }
    /**
     * @param route
     * @returns Returns null if it is not an object and undefined if it does not exist.
     */
    getObjectByRoute(route) {
        if (this.data === null || typeof this.data !== "object")
            return undefined;
        let obj = this.data;
        for (let i = 0; i < route.length; i++) {
            if (typeof obj !== "object" || obj === null)
                return undefined;
            const key = route[i];
            if (Array.isArray(obj)) {
                if (typeof key !== "number")
                    return undefined;
                obj = obj[key];
            }
            else {
                if (typeof key !== "string")
                    return undefined;
                obj = obj[key];
            }
            if (obj === undefined)
                return undefined;
        }
        if (typeof obj !== "object" || obj === null)
            return null;
        return obj;
    }
    /**
     * @param route
     * @param arrayAtLastPath Whether to create the last path as array. If null provided, this doesn't create any object at the last path.
     * @returns Whether there have been any changes.
     */
    createPath(route, arrayAtLastPath = null) {
        if (this.readonly)
            throw new EditReadonlyError();
        let isChanged = false;
        function changed() {
            isChanged = true;
        }
        this.data = this._createPath(this.data, arrayAtLastPath, changed, [...route]);
        return isChanged;
    }
    _createPath(data, arrayAtLastPath, changed, remainingRoute = []) {
        if (this.readonly)
            throw new EditReadonlyError();
        const key = remainingRoute.shift();
        const isArrayKey = typeof key === "number";
        const isObjectKey = !isArrayKey && key !== undefined;
        if (typeof data !== "object" || data === null || data === undefined || (isArrayKey && !Array.isArray(data)) || (isObjectKey && Array.isArray(data))) {
            // probably need fix
            if (isArrayKey || (key === undefined && arrayAtLastPath === true)) {
                const array = [];
                if (key !== undefined)
                    array[key] = this._createPath(null, arrayAtLastPath, changed, remainingRoute);
                changed();
                return array;
            }
            else if (isObjectKey || (key === undefined && arrayAtLastPath === false)) {
                const obj = {};
                if (key !== undefined)
                    obj[key] = this._createPath(null, arrayAtLastPath, changed, remainingRoute);
                changed();
                return obj;
            }
            else if (data === undefined) {
                // key === undefined && arrayAtLastPath === null && data === undefined
                changed();
                return null;
            }
            else {
                // key === undefined && arrayAtLastPath === null && data !== undefined
                // fix not needed
                return data;
            }
        }
        else if (key === undefined) {
            // fix not needed
            return data;
        }
        else {
            // fix not needed
            // Needless if statement but to avoid type errors.
            if (Array.isArray(data)) {
                data[key] = this._createPath(data[key], arrayAtLastPath, changed, remainingRoute);
            }
            else {
                data[key] = this._createPath(data[key], arrayAtLastPath, changed, remainingRoute);
            }
            return data;
        }
    }
}
exports.JsonManager = JsonManager;
class PathResolver extends JsonManager {
    constructor(manager, route, currentData) {
        super(manager.jsonOptions, manager.data, manager.readonly, manager.fastMode, route);
        this._currentData = currentData;
        this.manager = manager;
    }
    get data() {
        return this.manager.data;
    }
    set data(value) {
        this.manager.data = value;
    }
    get(...keys) {
        const newRoute = [...this.route, ...keys];
        let currentData = undefined;
        if (this.fastMode) {
            currentData = this._currentData;
            const keyCount = keys.length;
            for (let i = 0; i < keyCount; i++) {
                const key = keys[i];
                if (Array.isArray(currentData)) {
                    currentData = currentData[key];
                }
                else {
                    currentData = currentData[key];
                }
            }
        }
        return new PathResolver(this.manager, newRoute, currentData);
    }
}
exports.PathResolver = PathResolver;
class EditReadonlyError extends Error {
}
exports.EditReadonlyError = EditReadonlyError;
class InvalidTypeError extends Error {
    constructor(value) {
        super(`Unexpected value ${typeof value === "string" ? `"${value}"` : value} (type: ${typeof value}) detected.`);
    }
}
exports.InvalidTypeError = InvalidTypeError;
