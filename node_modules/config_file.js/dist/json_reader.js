"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonReader = void 0;
const json_manager_1 = require("./json_manager");
const json_utils_1 = require("./json_utils");
/** Readonly but super fast */
class JsonReader {
    constructor(jsonOptions, data) {
        this.data = data;
        this.jsonOptions = jsonOptions;
    }
    /** @returns undefined if it does not exist */
    getValue(...key) {
        return getChild(this.data, ...key);
    }
    get(...keys) {
        return new JsonReader(this.jsonOptions, getChild(this.data, ...keys));
    }
    // number
    getAsNumber(...key) {
        const value = getChild(this.data, ...key);
        if (typeof value !== "number")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNumberWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (typeof value !== "number")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableNumber(...key) {
        const value = getChild(this.data, ...key);
        if (value !== null && typeof value !== "number")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableNumberWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (value !== null && typeof value !== "number")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    // string
    getAsString(...key) {
        const value = getChild(this.data, ...key);
        if (typeof value !== "string")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsStringWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (typeof value !== "string")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableString(...key) {
        const value = getChild(this.data, ...key);
        if (value !== null && typeof value !== "string")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableStringWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (value !== null && typeof value !== "string")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    // boolean
    getAsBoolean(...key) {
        const value = getChild(this.data, ...key);
        if (typeof value !== "boolean")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsBooleanWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (typeof value !== "boolean")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableBoolean(...key) {
        const value = getChild(this.data, ...key);
        if (value !== null && typeof value !== "boolean")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableBooleanWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (value !== null && typeof value !== "boolean")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    // bigint
    getAsBigint(...key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed");
        const value = getChild(this.data, ...key);
        if (typeof value !== "bigint")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsBigintWithDefault(defaultValue, ...key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed");
        const value = getChild(this.data, ...key);
        // TODO: remove casting
        if (value === undefined)
            return defaultValue;
        if (typeof value !== "bigint")
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableBigint(...key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed");
        const value = getChild(this.data, ...key);
        if (value !== null && typeof value !== "bigint")
            throw new json_manager_1.InvalidTypeError(value);
        // TODO: remove casting
        return value;
    }
    getAsNullableBigintWithDefault(defaultValue, ...key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed");
        const value = getChild(this.data, ...key);
        // TODO: remove casting
        if (value === undefined)
            return defaultValue;
        if (value !== null && typeof value !== "bigint")
            throw new json_manager_1.InvalidTypeError(value);
        // TODO: remove casting
        return value;
    }
    // number or bigint
    getAsNumberOrBigint(...key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed");
        const value = getChild(this.data, ...key);
        if (typeof value !== "number" && typeof value !== "bigint")
            throw new json_manager_1.InvalidTypeError(value);
        // TODO: remove casting
        return value;
    }
    getAsNumberOrBigintWithDefault(defaultValue, ...key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed");
        const value = getChild(this.data, ...key);
        // TODO: remove casting
        if (value === undefined)
            return defaultValue;
        if (typeof value !== "number" && typeof value !== "bigint")
            throw new json_manager_1.InvalidTypeError(value);
        // TODO: remove casting
        return value;
    }
    getAsNullableNumberOrBigint(...key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed");
        const value = getChild(this.data, ...key);
        if (value !== null && typeof value !== "number" && typeof value !== "bigint")
            throw new json_manager_1.InvalidTypeError(value);
        // TODO: remove casting
        return value;
    }
    getAsNullableNumberOrBigintWithDefault(defaultValue, ...key) {
        if (!this.jsonOptions.allowBigint)
            throw new Error("Bigint is not allowed");
        const value = getChild(this.data, ...key);
        // TODO: remove casting
        if (value === undefined)
            return defaultValue;
        if (value !== null && typeof value !== "number" && typeof value !== "bigint")
            throw new json_manager_1.InvalidTypeError(value);
        // TODO: remove casting
        return value;
    }
    // JsonObject
    getAsJsonObject(...key) {
        const value = getChild(this.data, ...key);
        if (!(0, json_utils_1.isFlexJsonObject)(this.jsonOptions, value))
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsJsonObjectWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (!(0, json_utils_1.isFlexJsonObject)(this.jsonOptions, value))
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableJsonObject(...key) {
        const value = getChild(this.data, ...key);
        if (value !== null && !(0, json_utils_1.isFlexJsonObject)(this.jsonOptions, value))
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableJsonObjectWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (value !== null && !(0, json_utils_1.isFlexJsonObject)(this.jsonOptions, value))
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    // JsonArray
    getAsJsonArray(...key) {
        const value = getChild(this.data, ...key);
        if (!(0, json_utils_1.isFlexJsonArray)(this.jsonOptions, value))
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsJsonArrayWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (!(0, json_utils_1.isFlexJsonArray)(this.jsonOptions, value))
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableJsonArray(...key) {
        const value = getChild(this.data, ...key);
        if (value !== null && !(0, json_utils_1.isFlexJsonArray)(this.jsonOptions, value))
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    getAsNullableJsonArrayWithDefault(defaultValue, ...key) {
        const value = getChild(this.data, ...key);
        if (value === undefined)
            return defaultValue;
        if (value !== null && !(0, json_utils_1.isFlexJsonArray)(this.jsonOptions, value))
            throw new json_manager_1.InvalidTypeError(value);
        return value;
    }
    // map
    mapEntry(callback) {
        if (this.data === null || typeof this.data !== "object")
            throw new json_manager_1.InvalidTypeError(this.data);
        const isArray = Array.isArray(this.data);
        const keys = isArray ? this.data.map((_, i) => i) : Object.keys(this.data);
        const keyCount = keys.length;
        const result = [];
        for (let i = 0; i < keyCount; i++) {
            const key = keys[i];
            const value = isArray ? this.data[key] : this.data[key];
            result.push(callback(key, new JsonReader(this.jsonOptions, value)));
        }
        return result;
    }
    mapArray(callback) {
        if (this.data === null || typeof this.data !== "object" || !Array.isArray(this.data))
            throw new json_manager_1.InvalidTypeError(this.data);
        const len = this.data.length;
        const result = [];
        for (let i = 0; i < len; i++) {
            result.push(callback(i, new JsonReader(this.jsonOptions, this.data[i])));
        }
        return result;
    }
    mapObject(callback) {
        if (this.data === null || typeof this.data !== "object" || Array.isArray(this.data))
            throw new json_manager_1.InvalidTypeError(this.data);
        const keys = Object.keys(this.data);
        const len = keys.length;
        const result = [];
        for (let i = 0; i < len; i++) {
            const key = keys[i];
            result.push(callback(key, new JsonReader(this.jsonOptions, this.data[key])));
        }
        return result;
    }
    // find
    findEntry(predicate) {
        if (this.data === null || typeof this.data !== "object")
            throw new json_manager_1.InvalidTypeError(this.data);
        const isArray = Array.isArray(this.data);
        const keys = isArray ? this.data.map((_, i) => i) : Object.keys(this.data);
        const keyCount = keys.length;
        for (let i = 0; i < keyCount; i++) {
            const key = keys[i];
            const value = isArray ? this.data[key] : this.data[key];
            const json = new JsonReader(this.jsonOptions, value);
            if (predicate(key, json))
                return [key, json];
        }
        return undefined;
    }
    findArray(predicate) {
        if (this.data === null || typeof this.data !== "object" || !Array.isArray(this.data))
            throw new json_manager_1.InvalidTypeError(this.data);
        const len = this.data.length;
        for (let i = 0; i < len; i++) {
            const json = new JsonReader(this.jsonOptions, this.data[i]);
            if (predicate(i, json))
                return [i, json];
        }
        return undefined;
    }
    findObject(predicate) {
        if (this.data === null || typeof this.data !== "object" || Array.isArray(this.data))
            throw new json_manager_1.InvalidTypeError(this.data);
        const keys = Object.keys(this.data);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
            const key = keys[i];
            const json = new JsonReader(this.jsonOptions, this.data[key]);
            if (predicate(key, json))
                return ([key, json]);
        }
        return undefined;
    }
    // filter
    filterEntry(predicate) {
        if (this.data === null || typeof this.data !== "object")
            throw new json_manager_1.InvalidTypeError(this.data);
        const isArray = Array.isArray(this.data);
        const keys = isArray ? this.data.map((_, i) => i) : Object.keys(this.data);
        const keyCount = keys.length;
        const result = [];
        for (let i = 0; i < keyCount; i++) {
            const key = keys[i];
            const value = isArray ? this.data[key] : this.data[key];
            const json = new JsonReader(this.jsonOptions, value);
            if (predicate(key, json)) {
                result.push([key, json]);
            }
        }
        return result;
    }
    filterArray(predicate) {
        if (this.data === null || typeof this.data !== "object" || !Array.isArray(this.data))
            throw new json_manager_1.InvalidTypeError(this.data);
        const len = this.data.length;
        const result = [];
        for (let i = 0; i < len; i++) {
            const json = new JsonReader(this.jsonOptions, this.data[i]);
            if (predicate(i, json)) {
                result.push([i, json]);
            }
        }
        return result;
    }
    filterObject(predicate) {
        if (this.data === null || typeof this.data !== "object" || Array.isArray(this.data))
            throw new json_manager_1.InvalidTypeError(this.data);
        const keys = Object.keys(this.data);
        const len = keys.length;
        const result = [];
        for (let i = 0; i < len; i++) {
            const key = keys[i];
            const json = new JsonReader(this.jsonOptions, this.data[key]);
            if (predicate(key, json)) {
                result.push([key, json]);
            }
        }
        return result;
    }
    // forEach
    forEachEntry(callback) {
        if (this.data === null || typeof this.data !== "object")
            throw new json_manager_1.InvalidTypeError(this.data);
        const isArray = Array.isArray(this.data);
        const keys = isArray ? this.data.map((_, i) => i) : Object.keys(this.data);
        const keyCount = keys.length;
        for (let i = 0; i < keyCount; i++) {
            const key = keys[i];
            const value = isArray ? this.data[key] : this.data[key];
            callback(key, new JsonReader(this.jsonOptions, value));
        }
    }
    forEachArray(callback) {
        if (this.data === null || typeof this.data !== "object" || !Array.isArray(this.data))
            throw new json_manager_1.InvalidTypeError(this.data);
        const len = this.data.length;
        for (let i = 0; i < len; i++) {
            callback(i, new JsonReader(this.jsonOptions, this.data[i]));
        }
    }
    forEachObject(callback) {
        if (this.data === null || typeof this.data !== "object" || Array.isArray(this.data))
            throw new json_manager_1.InvalidTypeError(this.data);
        const keys = Object.keys(this.data);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
            const key = keys[i];
            callback(key, new JsonReader(this.jsonOptions, this.data[key]));
        }
    }
    has(...keys) {
        return getChild(this.data, ...keys) !== undefined;
    }
}
exports.JsonReader = JsonReader;
function getChild(data, ...keys) {
    const keyCount = keys.length;
    for (let i = 0; i < keyCount; i++) {
        if (data === null || typeof data !== "object")
            return undefined;
        const key = keys[i];
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        data = data[key];
    }
    return data;
}
