import { ConfigFile, JsonObject, defaultJsonOptions } from "config_file.js";
import { ObjectKeysManager } from "./ObjectKeysManager";
import { EnkaClient } from "./EnkaClient";
import { excelKeyMap, ExcelType, IndexBy, SingleBy, ExcelJsonObject } from "./ExcelTransformer";
export type LoadedExcelDataMap = {
    [excel in keyof typeof excelKeyMap]: SingleBy<typeof excelKeyMap[excel]>;
};
export type ExcelDataMap = {
    [excel in keyof typeof excelKeyMap]: LoadedExcelDataMap[excel] | null;
};
export declare const languages: readonly ["chs", "cht", "de", "en", "es", "fr", "id", "jp", "kr", "pt", "ru", "th", "vi"];
export type LanguageCode = typeof languages[number];
export type LoadedLanguageMap = Record<LanguageCode, Record<string, string>>;
export type LanguageMap = {
    [key in LanguageCode]: LoadedLanguageMap[key] | null;
};
export interface FetchContentsOptions {
    useRawGenshinData: boolean;
    ghproxy: boolean;
}
export interface UpdateContentsOptions extends FetchContentsOptions {
    onUpdateStart?: (() => Promise<void>) | null;
    onUpdateEnd?: (() => Promise<void>) | null;
}
export interface AutoCacheUpdaterOptions extends UpdateContentsOptions {
    instant: boolean;
    timeout: number;
    onError?: ((error: Error) => Promise<void>) | null;
}
export declare class CachedAssetsManager {
    /** The client that instantiated this */
    readonly enka: EnkaClient;
    /** Default path of genshin cache data directory */
    readonly defaultCacheDirectoryPath: string;
    /** Path of directory where genshin cache data is stored */
    cacheDirectoryPath: string;
    /** Base URL for fetching game data */
    gameDataBaseUrl: string;
    _cacheUpdater: NodeJS.Timer | null;
    _githubCache: ConfigFile<typeof defaultJsonOptions> | null;
    _isFetching: boolean;
    constructor(enka: EnkaClient);
    /** Create the necessary folders and files, and if the directory [cacheDirectoryPath](#cacheDirectoryPath) did not exist, move the cache files from the default path. */
    cacheDirectorySetup(): Promise<void>;
    /** Obtains a text map for a specific language. */
    fetchLanguageData(lang: LanguageCode): Promise<Record<string, string>>;
    /**
     * @param useRawGenshinData Whether to fetch from gitlab repo ({@link https://gitlab.com/Dimbreath/AnimeGameData}) instead of downloading cache.zip
     * @returns Whether the game data update is available or not.
     */
    checkForUpdates(useRawGenshinData?: boolean): Promise<boolean>;
    /**
     * @param options.useRawGenshinData Whether to fetch from gitlab repo ({@link https://gitlab.com/Dimbreath/AnimeGameData}) instead of downloading cache.zip
     * @param options.ghproxy Whether to use ghproxy.com
     */
    fetchAllContents(options?: Partial<FetchContentsOptions>): Promise<void>;
    /**
     * @returns whether all genshin cache data files exist.
     */
    hasAllContents(): boolean;
    /**
     * @param options.useRawGenshinData Whether to fetch from gitlab repo ({@link https://gitlab.com/Dimbreath/AnimeGameData}) instead of downloading cache.zip
     * @param options.ghproxy Whether to use ghproxy.com
     * @returns true if there were any updates, false if there were no updates.
     */
    updateContents(options?: Partial<UpdateContentsOptions>): Promise<void>;
    /**
     * @param options.useRawGenshinData Whether to fetch from gitlab repo ({@link https://gitlab.com/Dimbreath/AnimeGameData}) instead of downloading cache.zip
     * @param options.ghproxy Whether to use ghproxy.com
     * @param options.timeout in milliseconds
     */
    activateAutoCacheUpdater(options?: Partial<AutoCacheUpdaterOptions>): void;
    /**
     * Disables the updater activated by [activateAutoCacheUpdater](#activateAutoCacheUpdater)
     */
    deactivateAutoCacheUpdater(): void;
    /**
     * @returns text map file path for a specific language
     */
    getLanguageDataPath(lang: LanguageCode, directory?: string): string;
    /**
     * @param name without extensions (.json)
     * @returns excel bin file path
     */
    getJSONDataPath(name: string): string;
    _getExcelDataPath(excel: ExcelType): string;
    _getExcelData<T extends ExcelType>(excel: T): SingleBy<typeof excelKeyMap[T]>;
    getExcelData<T extends ExcelType, U extends (string | number)[]>(excel: T, ...keys: U): IndexBy<SingleBy<typeof excelKeyMap[T]>, U>;
    formatExcel<T extends ExcelType>(excel: T, data: ExcelJsonObject[]): SingleBy<typeof excelKeyMap[T]>;
    /**
     * @returns text map for a specific language
     */
    getLanguageData(lang: LanguageCode, directory?: string): JsonObject<string>;
    /**
     * @returns ObjectKeysManager of this
     */
    getObjectKeysManager(): ObjectKeysManager;
    /**
     * Clean memory of cache data.
     * Then reload data that was loaded before the clean if `reload` is true.
     * If `reload` is false, load each file as needed.
     */
    refreshAllData(reload?: boolean): void;
    /**
     * Remove all unused text map entries
     */
    removeUnusedTextData(data: LoadedExcelDataMap, langsData: LoadedLanguageMap, showLog?: boolean): LoadedLanguageMap;
    /**
     * Download the zip file, which contains genshin cache data, from {@link https://raw.githubusercontent.com/yuko1101/enka-network-api/main/cache.zip}
     * @param options.ghproxy Whether to use ghproxy.com
     */
    _downloadCacheZip(options?: {
        ghproxy?: boolean;
        stream?: boolean;
    }): Promise<void>;
    _unzipStream(stream: NodeJS.ReadableStream): Promise<void>;
    _unzipFile(filePath: string): Promise<void>;
    /**
     * @returns whether the cache is valid or not
     */
    _validateCache(showLog?: boolean): boolean;
}
