"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CharacterProfilePicture = exports.ProfilePicture = void 0;
const config_file_js_1 = require("config_file.js");
const ImageAssets_1 = require("./assets/ImageAssets");
const TextAssets_1 = require("./assets/TextAssets");
const Costume_1 = require("./character/Costume");
const AssetsNotFoundError_1 = require("../errors/AssetsNotFoundError");
const ExcelTransformer_1 = require("../client/ExcelTransformer");
class ProfilePicture {
    constructor(data, enka) {
        this.enka = enka;
        this._data = data;
        const json = new config_file_js_1.JsonReader(ExcelTransformer_1.excelJsonOptions, this._data);
        this.id = json.getAsNumber("id");
        this.icon = new ImageAssets_1.ImageAssets(json.getAsString("iconPath"), enka);
        this.name = new TextAssets_1.TextAssets(json.getAsNumber("nameTextMapHash"), enka);
        const keys = enka.cachedAssetsManager.getObjectKeysManager();
        this.type = json.getAsString(keys.profilePictureTypeKey);
    }
    static getById(id, enka) {
        const data = enka.cachedAssetsManager.getExcelData("ProfilePictureExcelConfigData", id);
        if (!data)
            throw new AssetsNotFoundError_1.AssetsNotFoundError("ProfilePicture", id);
        const json = new config_file_js_1.JsonReader(ExcelTransformer_1.excelJsonOptions, data);
        const keys = enka.cachedAssetsManager.getObjectKeysManager();
        const type = json.getAsString(keys.profilePictureTypeKey);
        switch (type) {
            case "PROFILE_PICTURE_UNLOCK_BY_AVATAR":
            case "PROFILE_PICTURE_UNLOCK_BY_COSTUME":
                return new CharacterProfilePicture(data, enka);
            default:
                return new ProfilePicture(data, enka);
        }
    }
    /**
     * @deprecated
     */
    static getByOldFormat(characterId, costumeId, enka) {
        const iconType = costumeId === null ? "PROFILE_PICTURE_UNLOCK_BY_AVATAR" : "PROFILE_PICTURE_UNLOCK_BY_COSTUME";
        const referenceId = costumeId === null ? characterId : costumeId;
        const keys = enka.cachedAssetsManager.getObjectKeysManager();
        const json = Object.values(enka.cachedAssetsManager.getExcelData("ProfilePictureExcelConfigData"))
            .map(p => new config_file_js_1.JsonReader(ExcelTransformer_1.excelJsonOptions, p))
            .find(j => j.getAsString(keys.profilePictureTypeKey) === iconType && j.getAsNumber("unlockParam") === referenceId);
        if (!json)
            throw new AssetsNotFoundError_1.AssetsNotFoundError("ProfilePicture", referenceId);
        return new CharacterProfilePicture(json.getAsJsonObject(), enka);
    }
}
exports.ProfilePicture = ProfilePicture;
class CharacterProfilePicture extends ProfilePicture {
    constructor(data, enka) {
        super(data, enka);
        const json = new config_file_js_1.JsonReader(config_file_js_1.defaultJsonOptions, this._data);
        const keys = enka.cachedAssetsManager.getObjectKeysManager();
        const type = json.getAsString(keys.profilePictureTypeKey);
        if (type !== "PROFILE_PICTURE_UNLOCK_BY_AVATAR" && type !== "PROFILE_PICTURE_UNLOCK_BY_COSTUME")
            throw new Error("Invalid type for CharacterProfilePicture");
        const costume = type === "PROFILE_PICTURE_UNLOCK_BY_COSTUME"
            ? Costume_1.Costume.getBySkinId(json.getAsNumber("unlockParam"), enka)
            : Costume_1.Costume.getDefaultCostumeByCharacterId(json.getAsNumber("unlockParam"), enka);
        this.type = type;
        this.costume = costume;
    }
}
exports.CharacterProfilePicture = CharacterProfilePicture;
