"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatProperty = void 0;
const config_file_js_1 = require("config_file.js");
const ExcelTransformer_1 = require("../client/ExcelTransformer");
const AssetsNotFoundError_1 = require("../errors/AssetsNotFoundError");
const constants_1 = require("../utils/constants");
const TextAssets_1 = require("./assets/TextAssets");
const ts_utils_1 = require("../utils/ts_utils");
class StatProperty {
    constructor(fightProp, value, enka) {
        this.fightProp = fightProp;
        this.enka = enka;
        const propData = enka.cachedAssetsManager.getExcelData("ManualTextMapConfigData", fightProp);
        if (!propData)
            throw new AssetsNotFoundError_1.AssetsNotFoundError("Fight Prop", fightProp);
        this._propData = propData;
        const propDataJson = new config_file_js_1.JsonReader(ExcelTransformer_1.excelJsonOptions, this._propData);
        this.fightPropName = new TextAssets_1.TextAssets(propDataJson.getAsNumber("textMapContentTextMapHash"), enka);
        this.isPercent = constants_1.percent.some(p => p === fightProp);
        this.rawValue = value;
        this.value = round(value, 8);
    }
    get valueText() {
        const fix = this.isPercent ? 1 : 0;
        return this.getMultipliedValue().toFixed(fix).replace(/\B(?=(\d{3})+(?!\d))/g, ",") + (this.isPercent ? "%" : "");
    }
    /**
     * Multiplies [value](#value) by 100 if it is a percentage
     */
    getMultipliedValue() {
        return this.value * (this.isPercent ? 100 : 1);
    }
    toString() {
        var _a;
        const name = (_a = this.fightPropName.get()) !== null && _a !== void 0 ? _a : "[Unknown]";
        return `${name}(${this.fightProp}): ${this.valueText}`;
    }
    static getFightPropTextAssets(fightProp, enka) {
        const propData = enka.cachedAssetsManager.getExcelData("ManualTextMapConfigData", fightProp);
        return propData ? new TextAssets_1.TextAssets(new config_file_js_1.JsonReader(ExcelTransformer_1.excelJsonOptions, propData).getAsNumber("textMapContentTextMapHash"), enka) : null;
    }
    static sumStatProperties(statProperties, enka) {
        const stats = {};
        for (const prop of statProperties) {
            if (stats[prop.fightProp] === undefined) {
                stats[prop.fightProp] = 0;
            }
            stats[prop.fightProp] += prop.value;
        }
        return Object.entries(stats).map(([fightProp, value]) => new StatProperty(fightProp, value, enka));
    }
    static parseAddProps(json, enka) {
        return json.filterArray((_, p) => p.has("propType") && p.has("value")).map(([, p]) => {
            const propType = p.getAsString("propType");
            if (propType === "FIGHT_PROP_NONE")
                return null;
            const value = p.getAsNumber("value");
            if (value === 0)
                return null;
            return new StatProperty(propType, value, enka);
        }).filter(ts_utils_1.nonNullable);
    }
}
exports.StatProperty = StatProperty;
function round(x, decimalPlaces = 0) {
    const p = Math.pow(10, decimalPlaces);
    return Math.round(x * p) / p;
}
